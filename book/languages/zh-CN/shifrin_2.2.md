## 2.1 符号和变量
在`Mathematica`中，变量(也许是复合的)是可以存储某些定义的符号. 更准确地说, 变量是一种不包含模式(pattern)的l.h.s全局规则(rule)(这实际上是我们对于变量的定义,它的意义将在后面进行解释).

###  2.2.1 合法的符号名
接下来我们要谈一谈合法符号的命名规则. 任何含有头符号(Head Symbol)并且未被系统使用的名字都可以和某些规则相关联(全局定义),换句话说,这样的名字可以当做合法的变量名或者函数名. 当然,符号名中虽然可以包含数字,但是却不能以数字打头. 符号名中也可以包含大小写字母,但注意`Mathematica`对字母的大小写是敏感的,所以像`<totalsum>`和`<totalSum>`将被当做是不同的符号名. 有一些特殊的保留字符也是不能够在符号的名字中使用的,比如 `@,#,$,%,^,&,*,!,~,‘.` 有可能让C程序员稍感意外的一点是,下划线`<_>`同样也是不能用在符号命名中的,它在 Mathematica 起着特殊的作用.

如果你不确定你的符号名是否合法,你总是可以通过 `Head[Unevaluated[yoursymbol]]` 命令来测试它的函数头(head): 如果返回值是`<Symbol>`,那么符号名是合法的. 这里我们是用`<Unevaluated>`的原因有点复杂,不好在此处彻底解释,总得来说,这样的用法是为了保证我们测试的是`<yoursymbol>`的头(head)而不是它的计算结果的头(head). 举个例子,假设你打算是用`<a&&True>` 作为一个符号名,下面是对它的测试结果:
	
	Head[a&&True]
	Symbol
看到 Symbol 作为输出, 我们很开心地给我们的符号赋值:

	a&&True = b
	Set::write: Tag And in a && True is Protected. >> 
	b
结果却沮丧地看到上面的错误信息.
之所以发生这种现象,是因为我们的符号名实际上是符号a和True的逻辑与(and),所以它的运算结果是`<a>`,而a的头(head)恰好是`Symbol`. 我们很快就会明白为什么上面的赋值是不合法的,这里如果用上`<Unevaluated>`,我们将会得到下结果:

	Head[Unevaluated[a&&True]]
	And

当我们讨论了更多的话题后,这样的函数行为将会非常容易理解.


	a&&True = 1
	Set::write: Tag And in a && True is Protected. >> 
	1
	
将自己创建的任何符号(变量名或函数名)的名字以小写字母开头,也被认为是一个很好的习惯, 这样一来,就不肯能和 `Mathematica` 系统自带符号发生冲突, 因为所有的系统自带符号名都是大写字母或者某个特殊的符号(比如$)打头的.



### 2.2.2 获取符号(symbols)的信息
对于每个头(head)为 `Symbol` (用 `Head[Unevaluated[symb]]`测试过,见前一小节) 的符号, 我们实际上有方法来显示当前和该符号相关联的信息. 这些信息包括与该符号相关联的规则(也即,定义), 一些其他的可能的特性(properties),比如属性(attributes), 对于系统符号来说,可能还包括对该符号用途用法的简单描述.

为了显示关联某个符号的全局规则(global rule),我们可以在该符号前加一个问号,也可以通过加两个问号或者`Information`命令得到进一步的信息,具体参见下面的例子:

	a = 3
	
下面我们来显示`<a>`的信息:

	?a
	
---
*Global`a*

或者,两个问号在这个例子中会输出一样的信息:
	
	??a
	
---
*Global`a*



	
	